"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _state = require("./state");
var _helpers = require("../../../helpers");
var _restApi = require("@frontegg/rest-api");
var _interfaces = require("../../interfaces");
var _helpers2 = require("../../helpers");
var _default = (store, api, sharedActions) => {
  const actions = sharedActions;
  const setBillingInformationState = state => {
    Object.assign(store.subscriptions.billing.information, state);
  };
  const resetBillingInformationState = () => {
    (0, _helpers.deepResetState)(store, ['subscriptions', 'billing', 'information'], _state.initialState);
  };
  const setInformationError = error => {
    setBillingInformationState({
      error,
      loading: false,
      fetching: false
    });
  };
  const loadSummaries = async (tenantId, forceActive) => {
    setBillingInformationState({
      loading: true
    });
    try {
      var _planResponse$price, _planResponse$price2;
      const summary = await api.subscriptions.getSubscriptionSummaries(tenantId);
      const {
        currentPlanId,
        externallyManaged
      } = summary;
      let subscriptionResponse = null;
      let planResponse;
      if (!externallyManaged) {
        // @ts-ignore // TODO: fix type in rest-api
        [, planResponse] = await Promise.all([actions.loadSubscription(), api.subscriptions.getSubscriptionPlan(currentPlanId)]);
        subscriptionResponse = store.subscriptions.billing.subscription.subscription || null;
      } else {
        // @ts-ignore // TODO: fix type in rest-api
        planResponse = await api.subscriptions.getSubscriptionPlan(currentPlanId);
      }
      setBillingInformationState((0, _extends2.default)({
        loading: false,
        fetching: false,
        summary
      }, subscriptionResponse ? {
        subscription: {
          id: subscriptionResponse.id,
          externalId: subscriptionResponse.externalId,
          startDate: subscriptionResponse.startDate,
          currentPeriodStart: subscriptionResponse.currentPeriodStart,
          currentPeriodEnd: subscriptionResponse.currentPeriodEnd,
          status: forceActive ? _interfaces.SubscriptionStatus.ACTIVE : (0, _helpers2.toSubscriptionStatus)(subscriptionResponse.status),
          cancellation: subscriptionResponse.cancellation && (0, _helpers2.toSubscriptionCancellation)(subscriptionResponse.cancellation),
          trialEnd: subscriptionResponse.trialEnd ? subscriptionResponse.trialEnd : null
        }
      } : {}, planResponse ? {
        plan: {
          id: planResponse.id,
          name: planResponse.name,
          description: planResponse.description,
          price: ((_planResponse$price = planResponse.price) == null ? void 0 : _planResponse$price.amount) || 0,
          currency: ((_planResponse$price2 = planResponse.price) == null ? void 0 : _planResponse$price2.currency) || 'usd',
          recurringInterval: 'month',
          slug: planResponse.slug
        }
      } : {}));
    } catch (e) {
      setInformationError((0, _helpers.errorHandler)(e));
    }
  };
  const loadBillingInformation = async forceActive => {
    var _store$subscriptions$, _store$auth$user;
    const paymentProvider = (_store$subscriptions$ = store.subscriptions.config.config) == null ? void 0 : _store$subscriptions$.paymentProvider;
    const tenantId = (_store$auth$user = store.auth.user) == null ? void 0 : _store$auth$user.tenantId;
    if (!paymentProvider || !tenantId) {
      setInformationError(new _restApi.FronteggApiError(!paymentProvider ? 'Internal feature failure' : 'Not authorized', 500, null));
      return;
    }
    await loadSummaries(tenantId, forceActive);
  };
  return {
    setBillingInformationState,
    resetBillingInformationState,
    loadSummaries,
    loadBillingInformation
  };
};
exports.default = _default;