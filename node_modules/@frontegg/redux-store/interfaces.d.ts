import { api, ContextOptions, fetch, FronteggApiError } from '@frontegg/rest-api';
import { AuthActions, AuthStateActions } from './auth';
import type { AuthState } from './auth/interfaces';
import type { ConnectivityActions } from './connectivity';
import type { ConnectivityState } from './connectivity/interfaces';
import { SubscriptionsActions, SubscriptionsStateActions } from './subscriptions';
import type { SubscriptionsState } from './subscriptions/interfaces';
import type { VendorActions } from './vendor';
import type { VendorState } from './vendor/interfaces';
import { AuditsState } from './audits/interfaces';
import { AuditsActions } from './audits';
import { OldAuditsState } from './audits-backward-compatibility/interfaces';
import { OldAuditsActions } from './audits-backward-compatibility';
import { DeepPartial } from './types';
/**
 * @deprecated use FronteggStore instead
 */
export type EnhancedStore = FronteggStore;
/**
 * @deprecated use direct actions instead
 */
export type Dispatch = (action: {
    type: string;
    payload?: any;
}) => void;
export interface FronteggStore {
    dispatch: Dispatch;
    getState: () => FronteggState;
    subscribe: (callback: () => void) => () => void;
    store: FronteggState;
    actions: FronteggActions;
    stateActions: FronteggStateActions;
    /**
     * Using redux store subscribe causes unpredictable callback calls: https://redux.js.org/api/store#subscribelistener
     *
     * This function aim to prevent unnecessary update by calling the callback with the updated frontegg state only on state reference change.
     * This function protect from redux unnecessary updates by reference comparison
     * Developed for vanilla js SDK
     *
     * @param callback called with the updated frontegg state for every store refresh
     * @returns redux unsubscribe function
     */
    subscribeStateChanged: (callback: (state: FronteggState) => void) => () => void;
}
export interface RootState {
    appName: string;
    context: ContextOptions;
    urlStrategy?: 'hash' | 'path';
    previewMode?: boolean;
}
export type FronteggState = {
    root: RootState;
    auth: AuthState;
    connectivity: ConnectivityState;
    subscriptions: SubscriptionsState;
    vendor: VendorState;
    auditLogs: AuditsState;
    /** @deprecated use auditLogs instead of audits */
    audits: OldAuditsState;
};
export type PartialFronteggState = Partial<{
    root: DeepPartial<RootState>;
    auth: DeepPartial<AuthState>;
    connectivity: Partial<ConnectivityState>;
    subscriptions: DeepPartial<SubscriptionsState>;
    vendor: DeepPartial<VendorState>;
    auditLogs: DeepPartial<AuditsState>;
    /** @deprecated use auditLogs instead of audits */
    audits: Partial<OldAuditsState>;
}>;
export type FronteggActions = AuthActions & ConnectivityActions & SubscriptionsActions & VendorActions & AuditsActions;
export type FronteggStateActions = {
    auth: AuthStateActions;
    connectivity: ConnectivityActions;
    subscriptions: SubscriptionsStateActions;
    vendor: VendorActions;
    auditLogs: AuditsActions;
    /** @deprecated use auditLogs instead of audits */
    audits: OldAuditsActions;
};
export type SharedActions = any;
export type RestApi = typeof api & {
    fetch: typeof fetch;
};
export type CallbackMethod<R = boolean> = (data: R | null, error?: FronteggApiError | any | unknown) => void;
export type WithCallback<T = object, R = boolean> = T & {
    callback?: CallbackMethod<R>;
};
export interface RetryConfig {
    retryCount: number;
    delay?: number;
    shouldRetryWhenNull?: boolean;
}
export type WithRetryConfig<T extends object> = T & {
    retryConfig?: RetryConfig;
};
export type WithStatus = {
    loading: boolean;
    error?: any;
    saving?: boolean;
};
export type WithId<T = object> = T & {
    id: string;
};
export type WithSilentLoad<T = {}> = T & {
    silentLoading?: boolean;
};
export type LoaderIndicatorState<T extends string, V = string | boolean> = Partial<{
    [key in T]: V;
}>;
export type ErrorsIndicatorState<T extends string> = Partial<{
    [key in T]: FronteggApiError | boolean;
}>;
