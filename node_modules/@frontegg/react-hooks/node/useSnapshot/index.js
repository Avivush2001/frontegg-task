"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSnapshot = useSnapshot;
var _react = _interopRequireWildcard(require("react"));
var _proxyCompare = require("proxy-compare");
var _shim = _interopRequireDefault(require("use-sync-external-store/shim"));
var _reduxStore = require("@frontegg/redux-store");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/// <reference types="react/experimental" />

// @ts-ignore

const {
  useSyncExternalStore
} = _shim.default;
const useAffectedDebugValue = (state, affected) => {
  const pathList = (0, _react.useRef)();
  (0, _react.useEffect)(() => {
    pathList.current = (0, _proxyCompare.affectedToPathList)(state, affected, true);
  });
  (0, _react.useDebugValue)(pathList.current);
};

// This is required only for performance.
// Ref: https://github.com/pmndrs/valtio/issues/519
const targetCache = new WeakMap();
/**
 * useSnapshot
 *
 * Create a local snapshot that catches changes. This hook actually returns a wrapped snapshot in a proxy for
 * render optimization instead of a plain object compared to `snapshot()` method.
 * Rule of thumb: read from snapshots, mutate the source.
 * The component will only re-render when the parts of the state you access have changed, it is render-optimized.
 *
 * @example A
 * function Counter() {
 *   const snap = useSnapshot(state)
 *   return (
 *     <div>
 *       {snap.count}
 *       <button onClick={() => ++state.count}>+1</button>
 *     </div>
 *   )
 * }
 *
 * [Notes]
 * Every object inside your proxy also becomes a proxy (if you don't use "ref"), so you can also use them to create
 * the local snapshot as seen on example B.
 *
 * @example B
 * function ProfileName() {
 *   const snap = useSnapshot(state.profile)
 *   return (
 *     <div>
 *       {snap.name}
 *     </div>
 *   )
 * }
 *
 * Beware that you still can replace the child proxy with something else so it will break your snapshot. You can see
 * above what happens with the original proxy when you replace the child proxy.
 *
 * > console.log(state)
 * { profile: { name: "valtio" } }
 * > childState = state.profile
 * > console.log(childState)
 * { name: "valtio" }
 * > state.profile.name = "react"
 * > console.log(childState)
 * { name: "react" }
 * > state.profile = { name: "new name" }
 * > console.log(childState)
 * { name: "react" }
 * > console.log(state)
 * { profile: { name: "new name" } }
 *
 * `useSnapshot()` depends on the original reference of the child proxy so if you replace it with a new one, the component
 * that is subscribed to the old proxy won't receive new updates because it is still subscribed to the old one.
 *
 * In this case we recommend the example C or D. On both examples you don't need to worry with re-render,
 * because it is render-optimized.
 *
 * @example C
 * const snap = useSnapshot(state)
 * return (
 *   <div>
 *     {snap.profile.name}
 *   </div>
 * )
 *
 * @example D
 * const { profile } = useSnapshot(state)
 * return (
 *   <div>
 *     {profile.name}
 *   </div>
 * )
 */
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = (0, _react.useRef)();
  const lastAffected = (0, _react.useRef)();
  let inRender = true;
  const currSnapshot = useSyncExternalStore((0, _react.useCallback)(callback => {
    const unsub = (0, _reduxStore.subscribe)(proxyObject, callback, notifyInSync);
    callback(); // Note: do we really need this?
    return unsub;
  }, [proxyObject, notifyInSync]), () => {
    const nextSnapshot = (0, _reduxStore.snapshot)(proxyObject, _react.default.use);
    try {
      if (!inRender && lastSnapshot.current && lastAffected.current && !(0, _proxyCompare.isChanged)(lastSnapshot.current, nextSnapshot, lastAffected.current, new WeakMap())) {
        // not changed
        return lastSnapshot.current;
      }
    } catch (e) {
      // ignore if a promise or something is thrown
    }
    return nextSnapshot;
  }, () => (0, _reduxStore.snapshot)(proxyObject, _react.default.use));
  inRender = false;
  const currAffected = new WeakMap();
  (0, _react.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = (0, _react.useMemo)(() => new WeakMap(), []); // per-hook proxyCache
  return (0, _proxyCompare.createProxy)(currSnapshot, currAffected, proxyCache, targetCache);
}