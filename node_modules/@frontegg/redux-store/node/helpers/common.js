"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.errorTraceId = exports.delay = exports.deepResetState = exports.deepClone = void 0;
exports.isProxy = isProxy;
exports.omitProps = omitProps;
exports.withRetryConfig = exports.retryIfNeeded = exports.retry = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _getValue = _interopRequireDefault(require("get-value"));
var _setValue = _interopRequireDefault(require("set-value"));
var _constants = require("../constants");
const delay = (ms = 500) => new Promise(resolve => {
  setTimeout(resolve, ms);
});
exports.delay = delay;
const retry = async (asyncFunc, retryCount, delay, shouldRetryWhenNull) => {
  let attempts = 0;
  while (attempts < retryCount - 1) {
    try {
      const response = await asyncFunc();
      if (shouldRetryWhenNull && response === null) {
        // throw to retry
        attempts++;
        if (attempts >= retryCount) {
          return response;
        }
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        return response;
      }
    } catch (error) {
      attempts++;
      if (attempts >= retryCount) {
        throw error;
      }
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  return await asyncFunc();
};
exports.retry = retry;
const retryIfNeeded = async (asyncFunc, config) => {
  if (!config) {
    return asyncFunc();
  }
  return retry(asyncFunc, config.retryCount, config.delay || 500, config.shouldRetryWhenNull);
};
exports.retryIfNeeded = retryIfNeeded;
const withRetryConfig = payload => (0, _extends2.default)({}, payload, {
  retryConfig: _constants.DEFAULT_RETRY_CONFIG
});
exports.withRetryConfig = withRetryConfig;
const errorTraceId = e => (e == null ? void 0 : e.traceId) || undefined;
exports.errorTraceId = errorTraceId;
function omitProps(props, keys) {
  const newProps = (0, _extends2.default)({}, props);
  keys.forEach(key => {
    delete newProps[key];
  });
  return newProps;
}
function shouldBeCloneable(o) {
  const type = typeof o;
  return (o == null ? void 0 : o.constructor) === {}.constructor || type === 'undefined' || o === null || type === 'boolean' || type === 'number' || type === 'string' || o instanceof Date || o instanceof RegExp || o instanceof Blob || o instanceof File || o instanceof FileList || o instanceof ArrayBuffer || o instanceof ImageData || o instanceof ImageBitmap || o instanceof Array || o instanceof Map || o instanceof Set;
}

/**
 * Check if the object is a proxy object to avoid cloning it
 */
function isProxy(obj) {
  if (obj === null || obj === undefined) {
    return;
  }
  const _shouldBeCloneable = shouldBeCloneable(obj);
  return _shouldBeCloneable && obj.__isProxy !== undefined;
}
const deepClone = objectToClone => {
  return JSON.parse(JSON.stringify(objectToClone));
};

/**
 * Used to reset the state of the store to the initial state
 * @param store - the store object
 * @param statePath - the path to the state that needs to be reset
 * @param initialState - the initial state object
 */
exports.deepClone = deepClone;
const deepResetState = (store, statePath, initialState) => {
  const initialLoginState = deepClone(initialState);
  const currentState = (0, _getValue.default)(store, statePath);
  for (const key in currentState) {
    if (key === '__isProxy') {
      continue;
    }
    if (key in initialLoginState) {
      (0, _setValue.default)(store, [...statePath, key], initialLoginState[key]);
    } else {
      (0, _setValue.default)(store, [...statePath, key], undefined);
    }
  }
};
exports.deepResetState = deepResetState;