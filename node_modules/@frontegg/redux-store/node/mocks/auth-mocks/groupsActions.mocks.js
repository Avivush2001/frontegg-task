"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _auth = require("../../auth");
var _helpers = require("../../helpers");
var _GroupsState = require("../../auth/GroupsState");
var _dummy = require("../dummy");
var _restApi = require("@frontegg/rest-api");
var _helpers2 = require("../helpers");
var _default = (store, api, actions) => {
  const originalActions = (0, _GroupsState.buildGroupsActions)(store, api, actions);
  const mockedActions = (0, _helpers2.mockActionsExpect)(originalActions, ['setGroupsState', 'resetUsersGroupsState', 'setUsersGroupsLoader', 'setUsersGroupsError']);
  mockedActions.loadGroups = async () => {
    const key = _auth.GroupsStateKeys.GET_GROUPS;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    const groups = _dummy.allGroupsDummy;
    mockedActions.setGroupsState({
      groups
    });
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.createGroup = async payload => {
    var _payload$callback;
    const key = _auth.GroupsStateKeys.CREATE_GROUP;
    const {
      groups
    } = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)(500);
    mockedActions.setGroupsState({
      groups: [(0, _extends2.default)({}, payload, {
        id: `${payload.name}ID`,
        managedBy: _restApi.GroupManagedByEnum.FRONTEGG
      }), ...(groups != null ? groups : [])]
    });
    payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, true);
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.updateGroup = async payload => {
    var _state$groups, _payload$name2, _payload$color, _payload$description, _payload$callback2;
    const key = _auth.GroupsStateKeys.UPDATE_GROUP;
    const state = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)(500);
    mockedActions.setGroupsState({
      groups: state == null ? void 0 : (_state$groups = state.groups) == null ? void 0 : _state$groups.map(group => {
        var _payload$name;
        return group.id === payload.groupId ? (0, _extends2.default)({}, payload, {
          id: payload.groupId,
          name: (_payload$name = payload == null ? void 0 : payload.name) != null ? _payload$name : '',
          managedBy: _restApi.GroupManagedByEnum.FRONTEGG
        }) : group;
      }),
      selectedGroup: (0, _extends2.default)({}, state == null ? void 0 : state.selectedGroup, {
        name: (_payload$name2 = payload == null ? void 0 : payload.name) != null ? _payload$name2 : '',
        color: (_payload$color = payload == null ? void 0 : payload.color) != null ? _payload$color : '',
        description: (_payload$description = payload == null ? void 0 : payload.description) != null ? _payload$description : ''
      })
    });
    payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, true);
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.deleteGroup = async payload => {
    var _state$groups2, _payload$callback3;
    const key = _auth.GroupsStateKeys.DELETE_GROUP;
    const state = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)(500);
    mockedActions.setGroupsState({
      groups: state == null ? void 0 : (_state$groups2 = state.groups) == null ? void 0 : _state$groups2.filter(group => group.id !== payload.groupId)
    });
    payload == null ? void 0 : (_payload$callback3 = payload.callback) == null ? void 0 : _payload$callback3.call(payload, true);
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.addRolesToGroup = async payload => {
    var _state$groups3, _payload$callback4;
    const key = _auth.GroupsStateKeys.ADD_ROLES_TO_GROUP;
    const state = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)(500);
    mockedActions.setGroupsState({
      groups: state == null ? void 0 : (_state$groups3 = state.groups) == null ? void 0 : _state$groups3.map(group => {
        var _group$roles;
        return group.id === payload.groupId ? (0, _extends2.default)({}, group, {
          roles: [...((_group$roles = group == null ? void 0 : group.roles) != null ? _group$roles : []), ...payload.roleIds.map(role => ({
            id: role,
            name: role
          }))]
        }) : group;
      })
    });
    payload == null ? void 0 : (_payload$callback4 = payload.callback) == null ? void 0 : _payload$callback4.call(payload, true);
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.deleteRolesFromGroup = async payload => {
    var _state$groups4, _payload$callback5;
    const key = _auth.GroupsStateKeys.DELETE_ROLES_FROM_GROUP;
    const state = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)(500);
    mockedActions.setGroupsState({
      groups: state == null ? void 0 : (_state$groups4 = state.groups) == null ? void 0 : _state$groups4.map(group => {
        var _group$roles2;
        return group.id === payload.groupId ? (0, _extends2.default)({}, group, {
          roles: group == null ? void 0 : (_group$roles2 = group.roles) == null ? void 0 : _group$roles2.filter(role => !payload.roleIds.includes(role.id))
        }) : group;
      })
    });
    payload == null ? void 0 : (_payload$callback5 = payload.callback) == null ? void 0 : _payload$callback5.call(payload, true);
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.addUsersToGroup = async payload => {
    var _state$groups5, _payload$callback6;
    const key = _auth.GroupsStateKeys.ADD_USERS_TO_GROUP;
    const state = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)(500);
    mockedActions.setGroupsState({
      groups: state == null ? void 0 : (_state$groups5 = state.groups) == null ? void 0 : _state$groups5.map(group => {
        var _group$users;
        return group.id === payload.groupId ? (0, _extends2.default)({}, group, {
          users: [...((_group$users = group == null ? void 0 : group.users) != null ? _group$users : []), ...payload.userIds.map(user => ({
            id: user,
            name: user
          }))]
        }) : group;
      })
    });
    payload == null ? void 0 : (_payload$callback6 = payload.callback) == null ? void 0 : _payload$callback6.call(payload, true);
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.deleteUsersFromGroup = async payload => {
    var _state$groups6, _payload$callback7;
    const key = _auth.GroupsStateKeys.DELETE_USERS_FROM_GROUP;
    const state = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)(500);
    mockedActions.setGroupsState({
      groups: state == null ? void 0 : (_state$groups6 = state.groups) == null ? void 0 : _state$groups6.map(group => {
        var _group$users2;
        return group.id === payload.groupId ? (0, _extends2.default)({}, group, {
          users: group == null ? void 0 : (_group$users2 = group.users) == null ? void 0 : _group$users2.filter(user => !payload.userIds.includes(user.id))
        }) : group;
      })
    });
    payload == null ? void 0 : (_payload$callback7 = payload.callback) == null ? void 0 : _payload$callback7.call(payload, true);
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.getGroupConfiguration = async () => {
    const key = _auth.GroupsStateKeys.GET_GROUP_CONFIGURATION;
    const {
      groupsConfiguration
    } = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    if (groupsConfiguration) {
      mockedActions.setGroupsState({
        groupsConfiguration: (0, _extends2.default)({}, groupsConfiguration)
      });
    }
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  mockedActions.updateGroupConfiguration = async payload => {
    const key = _auth.GroupsStateKeys.UPDATE_GROUP_CONFIGURATION;
    const {
      groupsConfiguration
    } = store.auth.groupsState;
    mockedActions.setUsersGroupsLoader({
      key,
      value: true
    });
    if (groupsConfiguration) {
      mockedActions.setGroupsState({
        groupsConfiguration: (0, _extends2.default)({}, groupsConfiguration, payload)
      });
    }
    mockedActions.setUsersGroupsLoader({
      key,
      value: false
    });
  };
  return mockedActions;
};
exports.default = _default;