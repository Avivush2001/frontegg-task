import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
const _excluded = ["events", "url"],
  _excluded2 = ["events", "url"];
import { SignUpStage } from './interfaces';
import { deepResetState, errorHandler, retryIfNeeded } from '../../helpers';
import { initialState } from './state';
import { AuthStrategyEnum, ContextHolder } from '@frontegg/rest-api';
import { prepareIdentifiersForSignup, isMfaRequired } from '../helpers';
import { AuthenticationTypes } from '../interfaces';
import { GTMEventAction, reportGTMEvent } from '../../helpers/gtm';
import { DEFAULT_RETRY_CONFIG } from '../../constants';
import { LoginStep } from '../../toolkit';
export default ((store, api, sharedActions) => {
  const actions = sharedActions;
  const contextHolder = ContextHolder.for(store.root.appName);
  const setSignUpState = state => {
    Object.assign(store.auth.signUpState, state);
  };
  const resetSignUpState = () => {
    deepResetState(store, ['auth', 'signUpState'], initialState);
  };
  const resetSignUpStateSoft = () => {
    const {
      allowSignUps,
      allowNotVerifiedUsersLogin
    } = store.auth.signUpState;
    resetSignUpState();
    setSignUpState({
      allowSignUps,
      allowNotVerifiedUsersLogin
    });
  };
  const reportSignupCompletion = (payload, userId, tenantId, activationToken, events, authenticationType = AuthenticationTypes.PASSWORD) => {
    var _events$signUpComplet;
    const {
      email,
      name,
      companyName,
      phoneNumber,
      url
    } = payload;
    const signUpCompletePayload = {
      email,
      name,
      companyName,
      url,
      phoneNumber: phoneNumber || undefined,
      authenticationType,
      id: userId,
      tenantId,
      createdAt: new Date(),
      activationToken
    };
    events == null ? void 0 : (_events$signUpComplet = events.signUpComplete) == null ? void 0 : _events$signUpComplet.call(events, signUpCompletePayload);
    reportGTMEvent(GTMEventAction.SIGNUP_COMPLETED, signUpCompletePayload);
  };
  const signUpUserWithPhoneNumber = async _payload => {
    const {
        events
      } = _payload,
      payload = _objectWithoutPropertiesLoose(_payload, _excluded);
    setSignUpState({
      loading: true
    });
    if (!payload.phoneNumber) {
      throw new Error('Phone number is required for phone number signup');
    }
    try {
      var _store$auth$securityP, _grecaptcha, _grecaptcha$execute;
      const {
        routes,
        onRedirectTo
      } = store.auth;
      const {
        tenantId,
        userId,
        activationToken
      } = await api.auth.signUpUserWithPhoneNumber(prepareIdentifiersForSignup(payload));
      if (!payload.invitationToken) {
        reportSignupCompletion(payload, userId, tenantId, activationToken, events, AuthenticationTypes.PHONE_NUMBER);
      }
      const {
        enabled: captchaEnabled,
        siteKey
      } = (_store$auth$securityP = store.auth.securityPolicyState.captchaPolicy.policy) != null ? _store$auth$securityP : {};
      const recaptchaToken = captchaEnabled && siteKey ? await ((_grecaptcha = window.grecaptcha) == null ? void 0 : (_grecaptcha$execute = _grecaptcha.execute) == null ? void 0 : _grecaptcha$execute.call(_grecaptcha, {
        action: 'login'
      })) : '';
      actions.passwordlessPreLogin({
        recaptchaToken,
        phoneNumber: payload.phoneNumber,
        type: AuthStrategyEnum.SmsCode,
        callback: (success, error) => {
          if (!success && error) {
            throw error;
          }
          onRedirectTo(routes.loginUrl);
          actions.setLoginState({
            step: LoginStep.loginWithSmsOtc,
            phoneNumber: payload.phoneNumber
          });
        }
      });
    } catch (e) {
      contextHolder.setAccessToken(null);
      contextHolder.setUser(null);
      setSignUpState({
        error: errorHandler(e)
      });
    } finally {
      setSignUpState({
        loading: false
      });
    }
  };
  const signUpUser = async _payload => {
    const {
        events
      } = _payload,
      payload = _objectWithoutPropertiesLoose(_payload, _excluded2);
    setSignUpState({
      loading: true
    });
    const phoneNumberStrategy = store.auth.signUpState.strategies.phoneNumber;
    if (phoneNumberStrategy != null && phoneNumberStrategy.required && phoneNumberStrategy != null && phoneNumberStrategy.enabled && payload.phoneNumber) {
      return signUpUserWithPhoneNumber(_payload);
    }
    try {
      const {
        routes,
        onRedirectTo
      } = store.auth;
      const {
        shouldActivate,
        user,
        tenantId,
        userId,
        tenants = [],
        activeTenant,
        activationToken
      } = await api.auth.signUpUser(prepareIdentifiersForSignup(payload));
      if (!payload.invitationToken) {
        reportSignupCompletion(payload, userId, tenantId, activationToken, events);
      }
      if (!shouldActivate && user && isMfaRequired(user, store.root.appName)) {
        const mfaRequiredState = await actions.getMfaRequiredState(user, DEFAULT_RETRY_CONFIG, true, payload.email);
        actions.setAuthState(mfaRequiredState);
        onRedirectTo(routes.loginUrl);
      } else if (shouldActivate && activationToken) {
        const searchParams = new URLSearchParams({
          userId: userId || '',
          token: activationToken || ''
        });
        const url = `${routes.activateWithOTCUrl}?${searchParams.toString()}`;
        setSignUpState({
          loading: false,
          shouldActivate,
          stage: SignUpStage.SignUpSuccess
        });
        onRedirectTo(url);
      } else {
        const tenantsState = store.auth.tenantsState;
        setSignUpState({
          loading: false,
          shouldActivate,
          stage: SignUpStage.SignUpSuccess
        });
        actions.setAuthState({
          user,
          isAuthenticated: !!(user != null && user.accessToken),
          tenantsState: _extends({}, tenantsState, {
            tenants,
            activeTenant
          })
        });
      }
    } catch (e) {
      contextHolder.setAccessToken(null);
      contextHolder.setUser(null);
      setSignUpState({
        error: errorHandler(e)
      });
    } finally {
      setSignUpState({
        loading: false
      });
    }
  };
  const loadAllowSignUps = async payload => {
    setSignUpState({
      loading: true
    });
    try {
      var _payload$callback;
      const policy = await retryIfNeeded(api.auth.getVendorConfig, payload == null ? void 0 : payload.retryConfig);
      const policyWithCustomLoginAuthStrategy = await actions.__getSecurityPolicyPublicStateWithCustomLogin(policy, payload == null ? void 0 : payload.retryConfig);
      const {
        allowSignups: allowSignUps,
        allowNotVerifiedUsersLogin
      } = policy;
      setSignUpState({
        loading: false,
        allowSignUps,
        allowNotVerifiedUsersLogin,
        firstLoad: false
      });
      actions.setSecurityPolicyPublicState({
        policy: policyWithCustomLoginAuthStrategy,
        loading: false
      });
      payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, policyWithCustomLoginAuthStrategy || policy);
    } catch (e) {
      var _payload$callback2;
      setSignUpState({
        loading: false,
        error: errorHandler(e),
        firstLoad: false
      });
      payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
    }
  };
  const loadSignUpStrategies = async () => {
    try {
      const strategies = await api.auth.getSignUpStrategies();
      setSignUpState({
        strategies: strategies.reduce((acc, {
          isActive,
          strategy,
          isRequired
        }) => {
          acc[strategy] = {
            enabled: isActive,
            required: isRequired
          };
          return acc;
        }, {})
      });
    } catch (error) {}
  };
  return {
    setSignUpState,
    resetSignUpState,
    resetSignUpStateSoft,
    signUpUser,
    signUpUserWithPhoneNumber,
    loadAllowSignUps,
    loadSignUpStrategies
  };
});