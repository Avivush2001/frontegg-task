"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _helpers = require("../../helpers");
var _dummy = require("../dummy");
var _SSOState = require("../../auth/SSOState");
var _helpers2 = require("../helpers");
const _excluded = ["callback", "samlVendor"];
var _default = (store, api, actions) => {
  const originalActions = (0, _SSOState.buildSSOActions)(store, api, actions);
  const mockedActions = (0, _helpers2.mockActionsExpect)(originalActions, ['setSSOState', 'resetSSOState']);
  mockedActions.loadSSOConfigurations = async () => {
    mockedActions.setSSOState({
      loading: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSSOState({
      samlConfiguration: _dummy.samlConfigurationDemo,
      loading: false,
      firstLoad: false
    });
  };
  mockedActions.saveSSOConfigurations = async payload => {
    var _samlMetadataDemo$con, _samlMetadataDemo$con2;
    const {
        callback,
        samlVendor
      } = payload,
      newSamlConfiguration = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded);
    const oldSamlConfiguration = _dummy.ssoStateDemo.samlConfiguration;
    const samlConfiguration = (0, _extends2.default)({}, oldSamlConfiguration, newSamlConfiguration);
    let loaderKey = 'saving';
    if ((samlConfiguration == null ? void 0 : samlConfiguration.enabled) !== oldSamlConfiguration.enabled) {
      loaderKey = 'loading';
    }
    const firstTimeConfigure = !(samlConfiguration != null && samlConfiguration.domain);
    if (firstTimeConfigure) {
      mockedActions.setSSOState({
        samlConfiguration: (0, _extends2.default)({}, oldSamlConfiguration, samlConfiguration)
      });
      return;
    } else {
      mockedActions.setSSOState({
        error: undefined,
        [loaderKey]: true
      });
    }
    await (0, _helpers.delay)();
    samlConfiguration.acsUrl = _dummy.samlMetadataDemo == null ? void 0 : (_samlMetadataDemo$con = _dummy.samlMetadataDemo.configuration) == null ? void 0 : _samlMetadataDemo$con.acsUrl;
    samlConfiguration.spEntityId = _dummy.samlMetadataDemo == null ? void 0 : (_samlMetadataDemo$con2 = _dummy.samlMetadataDemo.configuration) == null ? void 0 : _samlMetadataDemo$con2.spEntityId;
    const updateSamlConfiguration = (0, _helpers.omitProps)(samlConfiguration, ['validated', 'generatedVerification', 'createdAt', 'updatedAt']);
    if ((oldSamlConfiguration == null ? void 0 : oldSamlConfiguration.domain) !== (updateSamlConfiguration == null ? void 0 : updateSamlConfiguration.domain)) {
      updateSamlConfiguration.ssoEndpoint = '';
      updateSamlConfiguration.publicCertificate = '';
      updateSamlConfiguration.signRequest = false;
    }
    updateSamlConfiguration.type = samlVendor == null ? void 0 : samlVendor.toLowerCase();
    await (0, _helpers.delay)();
    mockedActions.setSSOState({
      samlConfiguration: updateSamlConfiguration,
      error: undefined,
      [loaderKey]: false
    });
    callback == null ? void 0 : callback(true);
  };
  mockedActions.saveSSOConfigurationsFile = async configFile => {
    const loaderKey = 'saving';
    mockedActions.setSSOState({
      error: undefined,
      [loaderKey]: true
    });
    const oldSamlConfiguration = store.auth.ssoState.samlConfiguration;
    const newSamlConfiguration = (0, _extends2.default)({}, oldSamlConfiguration, {
      enabled: true
    }, configFile[0]);
    mockedActions.setSSOState({
      samlConfiguration: newSamlConfiguration,
      error: undefined,
      [loaderKey]: false
    });
  };
  mockedActions.validateSSODomain = async payload => {
    const {
      callback
    } = payload != null ? payload : {};
    const samlConfiguration = _dummy.ssoStateDemo.samlConfiguration;
    mockedActions.setSSOState({
      error: undefined,
      saving: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSSOState({
      samlConfiguration: (0, _extends2.default)({}, samlConfiguration, {
        validated: true
      }),
      error: undefined,
      saving: false
    });
    callback == null ? void 0 : callback(true);
  };
  mockedActions.loadSSOAuthorizationRoles = async () => {
    await (0, _helpers.delay)();
    const data = {
      roleIds: ['1', '2', '3']
    };
    mockedActions.setSSOState({
      authorizationRoles: data.roleIds,
      error: undefined
    });
  };
  mockedActions.updateSSOAuthorizationRoles = async payload => {
    const {
      callback,
      authorizationRoles
    } = payload;
    mockedActions.setSSOState({
      error: undefined,
      saving: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSSOState({
      authorizationRoles,
      error: undefined,
      saving: false
    });
    callback == null ? void 0 : callback(true);
  };
  return mockedActions;
};
exports.default = _default;