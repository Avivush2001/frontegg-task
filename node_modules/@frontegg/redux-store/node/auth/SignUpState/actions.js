"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _interfaces = require("./interfaces");
var _helpers = require("../../helpers");
var _state = require("./state");
var _restApi = require("@frontegg/rest-api");
var _helpers2 = require("../helpers");
var _interfaces2 = require("../interfaces");
var _gtm = require("../../helpers/gtm");
var _constants = require("../../constants");
var _toolkit = require("../../toolkit");
const _excluded = ["events", "url"],
  _excluded2 = ["events", "url"];
var _default = (store, api, sharedActions) => {
  const actions = sharedActions;
  const contextHolder = _restApi.ContextHolder.for(store.root.appName);
  const setSignUpState = state => {
    Object.assign(store.auth.signUpState, state);
  };
  const resetSignUpState = () => {
    (0, _helpers.deepResetState)(store, ['auth', 'signUpState'], _state.initialState);
  };
  const resetSignUpStateSoft = () => {
    const {
      allowSignUps,
      allowNotVerifiedUsersLogin
    } = store.auth.signUpState;
    resetSignUpState();
    setSignUpState({
      allowSignUps,
      allowNotVerifiedUsersLogin
    });
  };
  const reportSignupCompletion = (payload, userId, tenantId, activationToken, events, authenticationType = _interfaces2.AuthenticationTypes.PASSWORD) => {
    var _events$signUpComplet;
    const {
      email,
      name,
      companyName,
      phoneNumber,
      url
    } = payload;
    const signUpCompletePayload = {
      email,
      name,
      companyName,
      url,
      phoneNumber: phoneNumber || undefined,
      authenticationType,
      id: userId,
      tenantId,
      createdAt: new Date(),
      activationToken
    };
    events == null ? void 0 : (_events$signUpComplet = events.signUpComplete) == null ? void 0 : _events$signUpComplet.call(events, signUpCompletePayload);
    (0, _gtm.reportGTMEvent)(_gtm.GTMEventAction.SIGNUP_COMPLETED, signUpCompletePayload);
  };
  const signUpUserWithPhoneNumber = async _payload => {
    const {
        events
      } = _payload,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_payload, _excluded);
    setSignUpState({
      loading: true
    });
    if (!payload.phoneNumber) {
      throw new Error('Phone number is required for phone number signup');
    }
    try {
      var _store$auth$securityP, _grecaptcha, _grecaptcha$execute;
      const {
        routes,
        onRedirectTo
      } = store.auth;
      const {
        tenantId,
        userId,
        activationToken
      } = await api.auth.signUpUserWithPhoneNumber((0, _helpers2.prepareIdentifiersForSignup)(payload));
      if (!payload.invitationToken) {
        reportSignupCompletion(payload, userId, tenantId, activationToken, events, _interfaces2.AuthenticationTypes.PHONE_NUMBER);
      }
      const {
        enabled: captchaEnabled,
        siteKey
      } = (_store$auth$securityP = store.auth.securityPolicyState.captchaPolicy.policy) != null ? _store$auth$securityP : {};
      const recaptchaToken = captchaEnabled && siteKey ? await ((_grecaptcha = window.grecaptcha) == null ? void 0 : (_grecaptcha$execute = _grecaptcha.execute) == null ? void 0 : _grecaptcha$execute.call(_grecaptcha, {
        action: 'login'
      })) : '';
      actions.passwordlessPreLogin({
        recaptchaToken,
        phoneNumber: payload.phoneNumber,
        type: _restApi.AuthStrategyEnum.SmsCode,
        callback: (success, error) => {
          if (!success && error) {
            throw error;
          }
          onRedirectTo(routes.loginUrl);
          actions.setLoginState({
            step: _toolkit.LoginStep.loginWithSmsOtc,
            phoneNumber: payload.phoneNumber
          });
        }
      });
    } catch (e) {
      contextHolder.setAccessToken(null);
      contextHolder.setUser(null);
      setSignUpState({
        error: (0, _helpers.errorHandler)(e)
      });
    } finally {
      setSignUpState({
        loading: false
      });
    }
  };
  const signUpUser = async _payload => {
    const {
        events
      } = _payload,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_payload, _excluded2);
    setSignUpState({
      loading: true
    });
    const phoneNumberStrategy = store.auth.signUpState.strategies.phoneNumber;
    if (phoneNumberStrategy != null && phoneNumberStrategy.required && phoneNumberStrategy != null && phoneNumberStrategy.enabled && payload.phoneNumber) {
      return signUpUserWithPhoneNumber(_payload);
    }
    try {
      const {
        routes,
        onRedirectTo
      } = store.auth;
      const {
        shouldActivate,
        user,
        tenantId,
        userId,
        tenants = [],
        activeTenant,
        activationToken
      } = await api.auth.signUpUser((0, _helpers2.prepareIdentifiersForSignup)(payload));
      if (!payload.invitationToken) {
        reportSignupCompletion(payload, userId, tenantId, activationToken, events);
      }
      if (!shouldActivate && user && (0, _helpers2.isMfaRequired)(user, store.root.appName)) {
        const mfaRequiredState = await actions.getMfaRequiredState(user, _constants.DEFAULT_RETRY_CONFIG, true, payload.email);
        actions.setAuthState(mfaRequiredState);
        onRedirectTo(routes.loginUrl);
      } else if (shouldActivate && activationToken) {
        const searchParams = new URLSearchParams({
          userId: userId || '',
          token: activationToken || ''
        });
        const url = `${routes.activateWithOTCUrl}?${searchParams.toString()}`;
        setSignUpState({
          loading: false,
          shouldActivate,
          stage: _interfaces.SignUpStage.SignUpSuccess
        });
        onRedirectTo(url);
      } else {
        const tenantsState = store.auth.tenantsState;
        setSignUpState({
          loading: false,
          shouldActivate,
          stage: _interfaces.SignUpStage.SignUpSuccess
        });
        actions.setAuthState({
          user,
          isAuthenticated: !!(user != null && user.accessToken),
          tenantsState: (0, _extends2.default)({}, tenantsState, {
            tenants,
            activeTenant
          })
        });
      }
    } catch (e) {
      contextHolder.setAccessToken(null);
      contextHolder.setUser(null);
      setSignUpState({
        error: (0, _helpers.errorHandler)(e)
      });
    } finally {
      setSignUpState({
        loading: false
      });
    }
  };
  const loadAllowSignUps = async payload => {
    setSignUpState({
      loading: true
    });
    try {
      var _payload$callback;
      const policy = await (0, _helpers.retryIfNeeded)(api.auth.getVendorConfig, payload == null ? void 0 : payload.retryConfig);
      const policyWithCustomLoginAuthStrategy = await actions.__getSecurityPolicyPublicStateWithCustomLogin(policy, payload == null ? void 0 : payload.retryConfig);
      const {
        allowSignups: allowSignUps,
        allowNotVerifiedUsersLogin
      } = policy;
      setSignUpState({
        loading: false,
        allowSignUps,
        allowNotVerifiedUsersLogin,
        firstLoad: false
      });
      actions.setSecurityPolicyPublicState({
        policy: policyWithCustomLoginAuthStrategy,
        loading: false
      });
      payload == null ? void 0 : (_payload$callback = payload.callback) == null ? void 0 : _payload$callback.call(payload, policyWithCustomLoginAuthStrategy || policy);
    } catch (e) {
      var _payload$callback2;
      setSignUpState({
        loading: false,
        error: (0, _helpers.errorHandler)(e),
        firstLoad: false
      });
      payload == null ? void 0 : (_payload$callback2 = payload.callback) == null ? void 0 : _payload$callback2.call(payload, null, e);
    }
  };
  const loadSignUpStrategies = async () => {
    try {
      const strategies = await api.auth.getSignUpStrategies();
      setSignUpState({
        strategies: strategies.reduce((acc, {
          isActive,
          strategy,
          isRequired
        }) => {
          acc[strategy] = {
            enabled: isActive,
            required: isRequired
          };
          return acc;
        }, {})
      });
    } catch (error) {}
  };
  return {
    setSignUpState,
    resetSignUpState,
    resetSignUpStateSoft,
    signUpUser,
    signUpUserWithPhoneNumber,
    loadAllowSignUps,
    loadSignUpStrategies
  };
};
exports.default = _default;