"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _SecurityCenterState = require("../../../auth/Security/SecurityCenterState");
var _auth = require("../../../auth");
var _helpers = require("../../../helpers");
var _dummy = require("../../dummy");
var _helpers2 = require("../../helpers");
var _default = (store, api, actions) => {
  const originalActions = (0, _SecurityCenterState.buildSecurityCenterActions)(store, api, actions);
  const mockedActions = (0, _helpers2.mockActionsExpect)(originalActions, ['setSecurityCenterState', 'setSecurityCenterStateError', 'setSecurityCenterStateLoader', 'resetSecurityCenterState']);
  mockedActions.loadRecommendations = async () => {
    const key = _auth.SecurityCenterStateKeys.RECOMMENDATIONS;
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSecurityCenterState({
      recommendations: _dummy.securityCenterRecommendationsMock.recommendations.items,
      score: _dummy.securityCenterRecommendationsMock.scoring.score
    });
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: false
    });
  };
  mockedActions.loadInsights = async () => {
    const key = _auth.SecurityCenterStateKeys.INSIGHTS;
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSecurityCenterState({
      insights: _dummy.securityCenterInsightsMock.insights.items
    });
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: false
    });
  };
  mockedActions.loadBreachedPasswordUsers = async () => {
    const key = _auth.SecurityCenterStateKeys.BREACHED_PASSWORD_USERS_TABLE;
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSecurityCenterState({
      breachedPasswordUsersTable: _dummy.securityCenterBreachedPasswordUsersMock
    });
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: false
    });
  };
  mockedActions.loadUnenrolledMfaUsers = async () => {
    const key = _auth.SecurityCenterStateKeys.UNENROLLED_MFA_USERS_TABLE;
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSecurityCenterState({
      unenrolledMfaUsersTable: _dummy.securityCenterUnenrolledMfaUsersMock
    });
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: false
    });
  };
  mockedActions.loadInactiveUsers = async () => {
    const key = _auth.SecurityCenterStateKeys.INACTIVE_USERS_TABLE;
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)();
    mockedActions.setSecurityCenterState({
      inactiveUsersTable: _dummy.securityCenterInactivityPasswordUsersMock
    });
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: false
    });
  };
  mockedActions.sendResetBreachedPasswordEmail = async payload => {
    const {
      callback
    } = payload;
    const key = _auth.SecurityCenterStateKeys.SEND_BREACHED_PASSWORD_EMAIL;
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: true
    });
    await (0, _helpers.delay)();
    callback == null ? void 0 : callback(true);
    mockedActions.setSecurityCenterStateLoader({
      key,
      value: false
    });
  };
  return mockedActions;
};
exports.default = _default;