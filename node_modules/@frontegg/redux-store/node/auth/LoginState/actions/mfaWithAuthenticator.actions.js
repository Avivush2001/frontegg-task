"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _interfaces = require("../interfaces");
var _helpers = require("../../../helpers");
var _helpers2 = require("../../helpers");
const _excluded = ["callback"];
var _default = (store, api, sharedActions) => {
  const actions = sharedActions;

  /**
   * @param tenants
   * @param isAuthenticated
   * @param isStepUp
   * @returns additional update object for the afterAuthenticationStateUpdate saga as part of MFA auth with authenticator app
   * @private
   */
  async function __buildPostAuthStateUpdate(tenants, isAuthenticated, isStepUp) {
    const loginState = store.auth.loginState;
    let additionalUpdate = {};
    if (!isStepUp) {
      const step = loginState.flow === _interfaces.LoginFlow.Login ? _interfaces.LoginStep.success : loginState.step;
      additionalUpdate = {
        loginState: {
          flow: loginState.flow,
          quickLoginToRegister: loginState.quickLoginToRegister,
          loading: false,
          step,
          error: undefined,
          tenants
        }
      };
    }
    return (0, _extends2.default)({}, additionalUpdate, {
      isAuthenticated
    });
  }

  /**
   * Handle after MFA authentication with authenticator app for login
   * @private
   */
  async function __postLoginMfaAuthenticator(isAuthenticated, user, callback) {
    const loginState = store.auth.loginState;
    if (loginState.flow !== _interfaces.LoginFlow.Login) return;
    const [securityCenterLoginFlows] = await actions.getFeatureFlags(['security-center-show-login-flows']);
    if (securityCenterLoginFlows && loginState.isBreachedPassword && !isAuthenticated) {
      actions.setLoginState({
        step: _interfaces.LoginStep.breachedPassword,
        loading: false
      });
      callback == null ? void 0 : callback(true);
      return;
    }
    if ((0, _helpers2.isResetPasswordRequired)(user, store.root.appName)) {
      actions.setLoginState({
        step: _interfaces.LoginStep.passwordRotationExpired,
        loading: false,
        resetPasswordToken: user.resetPasswordToken,
        userId: user.userId
      });
      callback == null ? void 0 : callback(true);
      return;
    }
    const shouldShowPasswordRotationPrompt = (0, _helpers2.shouldShowPasswordRotationPromptFunc)(user);
    if (shouldShowPasswordRotationPrompt) {
      actions.setLoginState({
        step: _interfaces.LoginStep.passwordRotationNotification,
        loading: false
      });
      callback == null ? void 0 : callback(true);
      return;
    }
    const shouldShowPrompt = await actions.__shouldShowPromptPasskeys();
    if (shouldShowPrompt) {
      actions.setLoginState({
        step: _interfaces.LoginStep.promptPasskeys,
        loading: false
      });
    } else {
      await actions.afterAuthNavigation();
    }
    callback == null ? void 0 : callback(true);
  }

  /**
   * Handle after MFA authentication with authenticator app for step up
   * @private
   */
  async function __postStepUpMfaAuthenticator(callback) {
    await actions.afterStepUpAuthNavigation();
    callback == null ? void 0 : callback(true);
  }

  /**
   * Utility function to handle MFA authentication with authenticator app
   * @param payload MFA with authenticator action payload
   * @param setLoadingAction set loading action
   * @param isStepUp true if this is a step-up authentication
   * @returns
   */
  const mfaWithAuthenticator = async (_ref, setLoadingAction, isStepUp) => {
    let {
        callback
      } = _ref,
      loginWithMfaPayload = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded);
    setLoadingAction({
      loading: true,
      error: undefined
    });
    try {
      const {
        user,
        tenants = [],
        activeTenant
      } = await api.auth.loginWithMfaV2(loginWithMfaPayload);
      const isAuthenticated = !!user.accessToken;
      const additionalUpdate = await __buildPostAuthStateUpdate(tenants, isAuthenticated, isStepUp);
      await actions.afterAuthenticationStateUpdate({
        user,
        tenants,
        activeTenant
      }, additionalUpdate);
      if (user.id) {
        localStorage.setItem('userId', user.id);
      }
      setLoadingAction({
        loading: false,
        error: undefined
      });
      if (isStepUp) {
        return await __postStepUpMfaAuthenticator(callback);
      }
      return await __postLoginMfaAuthenticator(isAuthenticated, user, callback);
    } catch (e) {
      setLoadingAction({
        loading: false,
        error: (0, _helpers.errorHandler)(e)
      });
      callback == null ? void 0 : callback(false, e);
    }
  };

  /**
   * Login with MFA with authenticator app - external saga
   * @param payload.mfaToken
   * @param payload.mfaDevices
   * @param payload.rememberDevice
   * @param payload.invitationToken
   * @param payload.callback - The callback function to be called after the request is done
   */
  const loginWithMfa = async payload => {
    return await mfaWithAuthenticator(payload, actions.setLoginState, false);
  };
  return {
    mfaWithAuthenticator,
    loginWithMfa
  };
};
exports.default = _default;