"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _state = require("./state");
var _restApi = require("@frontegg/rest-api");
var _helpers = require("../../helpers");
var _interfaces = require("./interfaces");
var _interfaces2 = require("../interfaces");
var _gtm = require("../../helpers/gtm");
var _helpers2 = require("../helpers");
var _interfaces3 = require("../TeamState/interfaces");
const _excluded = ["user"],
  _excluded2 = ["callback", "events"],
  _excluded3 = ["user"],
  _excluded4 = ["callback", "events"],
  _excluded5 = ["user"],
  _excluded6 = ["callback"],
  _excluded7 = ["callback"];
var _default = (store, api, sharedActions) => {
  const actions = sharedActions;
  const setActivateState = state => {
    Object.assign(store.auth.activateAccountState, state);
  };
  const resetActivateState = () => {
    (0, _helpers.deepResetState)(store, ['auth', 'activateAccountState'], _state.initialState);
  };
  const setActivateStrategyState = state => {
    Object.assign(store.auth.activateAccountState.activationStrategy, state);
  };
  const preActivateAccount = async payload => {
    const {
      userId,
      token
    } = payload;
    setActivateState({
      loading: true,
      step: _interfaces.ActivateAccountStep.activating
    });
    try {
      const isAuthenticated = store.auth.isAuthenticated;
      if (isAuthenticated) {
        await actions.silentLogout();
      }
      const strategy = await api.auth.getActivateAccountStrategy({
        userId,
        token
      });
      setActivateStrategyState({
        strategy,
        loading: false,
        error: undefined
      });
      if (strategy.shouldSetPassword) {
        setActivateState({
          loading: false,
          step: _interfaces.ActivateAccountStep.activatingForm
        });
      }
    } catch (e) {
      setActivateState({
        loading: false,
        error: (0, _helpers.errorHandler)(e)
      });
    }
  };
  const handleActivationResponse = async ({
    loginResponse,
    events,
    onRedirectTo,
    routes
  }) => {
    const {
        user
      } = loginResponse,
      rest = (0, _objectWithoutPropertiesLoose2.default)(loginResponse, _excluded);
    if (user.redirectLocation) {
      window.location.href = user.redirectLocation;
      return;
    }
    if ((0, _helpers2.isMfaRequired)(user, store.root.appName)) {
      setActivateState({
        step: _interfaces.ActivateAccountStep.success
      });
      const mfaRequiredState = await actions.getMfaRequiredState(user);
      actions.setAuthState(mfaRequiredState);
      await (0, _helpers.delay)(1000);
      onRedirectTo(routes.loginUrl, {
        preserveQueryParams: true
      });
    } else {
      var _events$userVerified;
      setActivateState({
        step: _interfaces.ActivateAccountStep.success
      });
      const userVerifiedPayload = {
        email: user.email,
        origin: _interfaces2.UserVerifiedOriginTypes.ACTIVATION_LINK,
        id: user.id,
        tenantId: user.tenantId,
        name: user.name,
        createdAt: new Date()
      };
      events == null ? void 0 : (_events$userVerified = events.userVerified) == null ? void 0 : _events$userVerified.call(events, userVerifiedPayload);
      (0, _gtm.reportGTMEvent)(_gtm.GTMEventAction.USER_VERIFIED, userVerifiedPayload);
      actions.afterAuthenticationStateUpdate((0, _extends2.default)({
        user
      }, rest), {
        isAuthenticated: true
      });
      await (0, _helpers.delay)(5000);
      await actions.afterAuthNavigation();
      resetActivateState();
    }
  };
  const activateAccount = async _payload => {
    const {
        callback,
        events
      } = _payload,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_payload, _excluded2);
    setActivateState({
      loading: true,
      submitting: true
    });
    try {
      const onRedirectTo = _restApi.ContextHolder.for(store.root.appName).onRedirectTo;
      const routes = store.auth.routes;
      const _await$api$auth$activ = await api.auth.activateAccountV2(payload),
        {
          user
        } = _await$api$auth$activ,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_await$api$auth$activ, _excluded3);
      setActivateState({
        submitting: false
      });
      await handleActivationResponse({
        loginResponse: (0, _extends2.default)({
          user
        }, rest),
        events,
        onRedirectTo,
        routes
      });
      callback == null ? void 0 : callback(true);
    } catch (e) {
      setActivateState({
        loading: false,
        error: (0, _helpers.errorHandler)(e)
      });
    }
  };
  const activateAccountWithCode = async _payload => {
    const {
        callback,
        events
      } = _payload,
      payload = (0, _objectWithoutPropertiesLoose2.default)(_payload, _excluded4);
    setActivateState({
      loading: true,
      submitting: true
    });
    try {
      const onRedirectTo = _restApi.ContextHolder.for(store.root.appName).onRedirectTo;
      const routes = store.auth.routes;
      const _await$api$auth$activ2 = await api.auth.activateAccountWithOTC(payload),
        {
          user
        } = _await$api$auth$activ2,
        rest = (0, _objectWithoutPropertiesLoose2.default)(_await$api$auth$activ2, _excluded5);
      setActivateState({
        submitting: false
      });
      await handleActivationResponse({
        loginResponse: (0, _extends2.default)({
          user
        }, rest),
        events,
        onRedirectTo,
        routes
      });
      callback == null ? void 0 : callback(true);
    } catch (e) {
      setActivateState({
        submitting: false,
        loading: false,
        error: (0, _helpers.errorHandler)(e),
        step: _interfaces.ActivateAccountStep.activating
      });
    }
  };
  const getActivateAccountStrategy = async payload => {
    const {
        callback
      } = payload,
      params = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded6);
    setActivateStrategyState({
      loading: true
    });
    try {
      const strategy = await api.auth.getActivateAccountStrategy(params);
      setActivateStrategyState({
        strategy,
        loading: false,
        error: undefined
      });
      callback == null ? void 0 : callback(strategy);
    } catch (e) {
      setActivateStrategyState({
        loading: false,
        error: (0, _helpers.errorHandler)(e)
      });
    }
  };
  const resendActivationEmail = async payload => {
    const {
        callback
      } = payload,
      body = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded7);
    actions.setTeamLoader({
      key: _interfaces3.TeamStateKeys.RESEND_ACTIVATE_LINK,
      value: body.email
    });
    setActivateState({
      loading: true
    });
    try {
      await api.auth.resendActivationEmail(body);
      setActivateState({
        loading: false,
        error: undefined,
        resentEmail: true
      });
      callback == null ? void 0 : callback(true);
    } catch (e) {
      setActivateState({
        loading: false,
        error: (0, _helpers.errorHandler)(e)
      });
      callback == null ? void 0 : callback(null, e);
    } finally {
      actions.setTeamLoader({
        key: _interfaces3.TeamStateKeys.RESEND_ACTIVATE_LINK,
        value: false
      });
    }
  };
  return {
    setActivateState,
    resetActivateState,
    setActivateStrategyState,
    activateAccount,
    preActivateAccount,
    getActivateAccountStrategy,
    resendActivationEmail,
    activateAccountWithCode
  };
};
exports.default = _default;