"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  createFronteggStore: true,
  createStore: true
};
exports.createStore = exports.createFronteggStore = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _valtio = require("../valtio");
var _restApi = require("@frontegg/rest-api");
var _auth = require("../auth");
Object.keys(_auth).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _auth[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _auth[key];
    }
  });
});
var _connectivity = require("../connectivity");
var _subscriptions = require("../subscriptions");
var _vendor = require("../vendor");
var _audits = require("../audits");
var _setValue = _interopRequireDefault(require("set-value"));
var _auditsBackwardCompatibility = require("../audits-backward-compatibility");
var _mocks = _interopRequireDefault(require("../mocks"));
var _proxy = require("./proxy");
var _interfaces = require("../interfaces");
Object.keys(_interfaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interfaces[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _interfaces[key];
    }
  });
});
/* eslint-disable @typescript-eslint/no-explicit-any */

/**
 * @deprecated use createStore instead
 */
const createFronteggStore = (rootInitialState, storeHolder, previewMode = false, authInitialState, overrideInitialState, builderMode = false, urlStrategy = 'path') => {
  return createStore({
    name: rootInitialState.appName,
    context: rootInitialState.context,
    storeHolder,
    previewMode,
    builderMode,
    urlStrategy,
    initialState: {
      root: (0, _extends2.default)({}, rootInitialState),
      auth: (0, _extends2.default)({}, overrideInitialState == null ? void 0 : overrideInitialState.auth, authInitialState),
      connectivity: (0, _extends2.default)({}, overrideInitialState == null ? void 0 : overrideInitialState.connectivity),
      subscriptions: (0, _extends2.default)({}, overrideInitialState == null ? void 0 : overrideInitialState.subscriptions),
      vendor: (0, _extends2.default)({}, overrideInitialState == null ? void 0 : overrideInitialState.vendor),
      auditLogs: (0, _extends2.default)({}, overrideInitialState == null ? void 0 : overrideInitialState.auditLogs),
      audits: (0, _extends2.default)({}, overrideInitialState == null ? void 0 : overrideInitialState.audits)
    }
  });
};
exports.createFronteggStore = createFronteggStore;
const createStore = options => {
  var _options$initialState, _options$initialState2, _options$initialState3, _options$initialState4, _options$initialState5, _options$initialState6, _options$initialState7;
  const {
    storeHolder
  } = options;
  const isSSR = typeof window === 'undefined';
  let holder = storeHolder;
  if (isSSR && storeHolder == null) {
    throw Error('createFronteggStore(initState, storeHolder) failed, storeHolder must not be null in Server-Side rendering');
  }
  if (!holder) {
    holder = window;
  }
  if (holder.store) {
    return holder.store;
  }
  const appName = options.name || 'default';
  const {
    context,
    previewMode = false,
    builderMode = false,
    urlStrategy = 'path'
  } = options;
  const contextHolder = _restApi.ContextHolder.for(appName);
  if (!previewMode && !builderMode) {
    contextHolder.setContext(context);
  }
  if (context.requestCredentials === undefined) {
    context.requestCredentials = 'include';
  }
  const authState = (0, _auth.createAuthState)((_options$initialState = options.initialState) == null ? void 0 : _options$initialState.auth);
  const connectivityState = (0, _connectivity.createConnectivityState)((_options$initialState2 = options.initialState) == null ? void 0 : _options$initialState2.connectivity);
  const subscriptionsState = (0, _subscriptions.createSubscriptionsState)((_options$initialState3 = options.initialState) == null ? void 0 : _options$initialState3.subscriptions);
  const vendorState = (0, _vendor.createVendorState)((_options$initialState4 = options.initialState) == null ? void 0 : _options$initialState4.vendor);
  const auditsState = (0, _audits.createAuditsState)((_options$initialState5 = options.initialState) == null ? void 0 : _options$initialState5.auditLogs);
  const oldAuditsState = (0, _auditsBackwardCompatibility.createOldAuditsState)((_options$initialState6 = options.initialState) == null ? void 0 : _options$initialState6.audits);
  const overrideAuthState = (_options$initialState7 = options.initialState) == null ? void 0 : _options$initialState7.auth;
  if (overrideAuthState) {
    Object.keys(overrideAuthState).forEach(key => {
      (0, _setValue.default)(authState, key, overrideAuthState[key], {
        merge: true
      });
    });
  }

  /** use parse and stringify to deep clone without any functions or references */
  const snapshotAuthState = JSON.parse(JSON.stringify(authState));
  const store = (0, _proxy.createProxy)({
    root: {
      appName,
      context,
      urlStrategy,
      previewMode
    },
    auth: authState,
    connectivity: connectivityState,
    subscriptions: subscriptionsState,
    vendor: vendorState,
    auditLogs: auditsState,
    audits: oldAuditsState
  });
  if (typeof window !== 'undefined' && window.localStorage && (window.localStorage['DEBUG_FRONTEGG_STORE'] === 'true' || process.env.NODE_ENV === 'development')) {
    (0, _valtio.devtools)(store, {
      name: `${appName} Store`,
      enabled: true
    });
  }
  const stateActions = {};
  const actions = {};
  contextHolder.setContext(options.context);
  contextHolder.setAppName(appName);
  const restApiInstance = (0, _restApi.createApiClient)(appName);
  const fetchInstance = new _restApi.FetchClient(appName);
  const api = (0, _extends2.default)({}, restApiInstance, {
    fetch: fetchInstance
  });
  if (options.previewMode || options.builderMode) {
    const {
      authActions,
      authStateActions,
      connectivityActions,
      subscriptionsActions,
      subscriptionsStateActions,
      vendorActions,
      auditsActions
    } = (0, _mocks.default)(store, api, actions, snapshotAuthState);
    stateActions.auth = authStateActions;
    stateActions.connectivity = connectivityActions;
    stateActions.subscriptions = subscriptionsStateActions;
    stateActions.vendor = vendorActions;
    stateActions.auditLogs = auditsActions;
    stateActions.audits = {};
    Object.assign(actions, (0, _extends2.default)({}, authActions, connectivityActions, subscriptionsActions, vendorActions, auditsActions));
    const fronteggStore = {
      dispatch: action => {
        setTimeout(() => {
          const [namespace, ...rest] = action.type.split('/');
          const actionName = rest.join('/');
          if (namespace === 'auth' && typeof authActions[actionName] === 'function') {
            authActions[actionName](action.payload);
          } else if (namespace === 'connectivity' && typeof connectivityActions[actionName] === 'function') {
            connectivityActions[actionName](action.payload);
          } else if (namespace === 'subscriptions' && typeof subscriptionsActions[actionName] === 'function') {
            subscriptionsActions[actionName](action.payload);
          } else if (namespace === 'vendor' && typeof vendorActions[actionName] === 'function') {
            vendorActions[actionName](action.payload);
          }
        });
      },
      getState: () => store,
      subscribe: callback => (0, _valtio.subscribe)(store, callback),
      subscribeStateChanged: callback => (0, _valtio.subscribe)(store, () => callback(store)),
      store,
      actions,
      stateActions
    };
    if (options.previewMode) {
      fronteggStore.dispatch({
        type: 'auth/requestAuthorize',
        payload: true
      });
    }
    if (holder) {
      holder.store = fronteggStore;
    }
    return fronteggStore;
  } else {
    const [authActions, authStateActions] = (0, _auth.buildAuthActions)(store, api, actions, snapshotAuthState);
    const connectivityActions = (0, _connectivity.buildConnectivityActions)(store, api, actions);
    const [subscriptionsActions, subscriptionsStateActions] = (0, _subscriptions.buildSubscriptionsActions)(store, api, actions);
    const vendorActions = (0, _vendor.buildVendorActions)(store, api, actions);
    const auditsActions = (0, _audits.buildAuditsActions)(store, api, actions);
    const oldAuditsActions = (0, _auditsBackwardCompatibility.buildOldAuditsActions)(store, api, actions);
    stateActions.auth = authStateActions;
    stateActions.connectivity = connectivityActions;
    stateActions.subscriptions = subscriptionsStateActions;
    stateActions.vendor = vendorActions;
    stateActions.auditLogs = auditsActions;
    stateActions.audits = oldAuditsActions;
    Object.assign(actions, (0, _extends2.default)({}, authActions, connectivityActions, subscriptionsActions, vendorActions, auditsActions));
    return {
      dispatch: action => {
        const [namespace, ...rest] = action.type.split('/');
        const actionName = rest.join('/');
        if (namespace === 'auth' && typeof authActions[actionName] === 'function') {
          authActions[actionName](action.payload);
        } else if (namespace === 'connectivity' && typeof connectivityActions[actionName] === 'function') {
          connectivityActions[actionName](action.payload);
        } else if (namespace === 'subscriptions' && typeof subscriptionsActions[actionName] === 'function') {
          subscriptionsActions[actionName](action.payload);
        } else if (namespace === 'vendor' && typeof vendorActions[actionName] === 'function') {
          vendorActions[actionName](action.payload);
        }
      },
      getState: () => store,
      subscribe: callback => (0, _valtio.subscribe)(store, callback),
      subscribeStateChanged: callback => (0, _valtio.subscribe)(store, () => callback(store)),
      store,
      actions,
      stateActions
    };
  }
};
exports.createStore = createStore;