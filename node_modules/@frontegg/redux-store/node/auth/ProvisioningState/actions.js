"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _helpers = require("../../helpers");
var _state = require("./state");
const _excluded = ["callback"],
  _excluded2 = ["id"];
var _default = (store, api, sharedActions) => {
  const actions = sharedActions;
  const setProvisioningState = state => {
    Object.assign(store.auth.provisioningState, state);
  };
  const resetProvisioningState = () => {
    (0, _helpers.deepResetState)(store, ['auth', 'provisioningState'], _state.initialState);
  };

  /**
   * @private
   */
  const __loadCountForConnection = async (connection, retryConfig) => {
    const {
      count
    } = await (0, _helpers.retryIfNeeded)(() => api.directory.countConfigurationUsers(connection.id), retryConfig);
    return (0, _extends2.default)({}, connection, {
      count
    });
  };
  const loadProvisionConnections = async payload => {
    setProvisioningState({
      loading: true,
      error: null
    });
    try {
      const retryConfig = payload == null ? void 0 : payload.retryConfig;
      const connections = await (0, _helpers.retryIfNeeded)(() => api.directory.getConfigs(), retryConfig);
      const connectionsWithCount = await Promise.all(connections.map(connection => __loadCountForConnection(connection, retryConfig)));
      setProvisioningState({
        connections: connectionsWithCount,
        loading: false
      });
    } catch (e) {
      setProvisioningState({
        error: (0, _helpers.errorHandler)(e),
        loading: false
      });
    }
  };
  const createProvisionConnection = async payload => {
    const {
        callback
      } = payload,
      newConnectionBody = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded);
    setProvisioningState({
      loading: true,
      error: null
    });
    try {
      const newConnectionResponse = await api.directory.createConfiguration(newConnectionBody);
      const connections = await api.directory.getConfigs();
      const connectionsWithCount = await Promise.all(connections.map(connection => __loadCountForConnection(connection)));
      setProvisioningState({
        connections: connectionsWithCount,
        loading: false
      });
      callback == null ? void 0 : callback(newConnectionResponse);
    } catch (e) {
      setProvisioningState({
        error: (0, _helpers.errorHandler)(e),
        loading: false
      });
    }
  };
  const deleteProvisionConnection = async payload => {
    const {
      id,
      callback
    } = payload;
    setProvisioningState({
      loading: true,
      error: null
    });
    try {
      await api.directory.deleteConfiguration(id, payload.deleteAll);
      const connections = await api.directory.getConfigs();
      const connectionsWithCount = await Promise.all(connections.map(connection => __loadCountForConnection(connection)));
      setProvisioningState({
        connections: connectionsWithCount,
        loading: false
      });
      callback == null ? void 0 : callback(true);
    } catch (e) {
      setProvisioningState({
        error: (0, _helpers.errorHandler)(e),
        loading: false
      });
      callback == null ? void 0 : callback(false, e);
    }
  };
  const updateProvisionConnection = async payload => {
    const {
        id
      } = payload,
      updateRequest = (0, _objectWithoutPropertiesLoose2.default)(payload, _excluded2);
    setProvisioningState({
      loading: true,
      error: null
    });
    try {
      await api.directory.updateConfiguration(id, updateRequest);
      const connections = await api.directory.getConfigs();
      const connectionsWithCount = await Promise.all(connections.map(connection => __loadCountForConnection(connection)));
      setProvisioningState({
        connections: connectionsWithCount,
        loading: false
      });
    } catch (e) {
      setProvisioningState({
        error: (0, _helpers.errorHandler)(e),
        loading: false
      });
    }
  };
  return {
    setProvisioningState,
    resetProvisioningState,
    __loadCountForConnection,
    loadProvisionConnections,
    createProvisionConnection,
    deleteProvisionConnection,
    updateProvisionConnection
  };
};
exports.default = _default;